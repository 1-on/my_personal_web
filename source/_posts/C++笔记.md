---
title: C++学习笔记
abbrlink: 1
categories: 学习笔记
tags: C++
---

## 第二章

### 2.1 函数定义

c++中，定义函数的时候可以让**最右边的连续若干个**参数有[缺省值](https://so.csdn.net/so/search?q=缺省值&spm=1001.2101.3001.7020)，在调用函数的时候，如果不写相应位置的参数，则调用的参数就为缺省值。

<font color=red>***注意是右往左连续参数**</font>

```C++
int func(int a=1,int b,int c=2){} //不合法
```

<!-- more -->

### 2.2 函数重载

C++ 允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载（Function Overloading）。

*重载的规则：*

- 函数名称必须相同。
- 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。
- 函数的返回类型可以相同也可以不相同。
- 仅仅返回类型不同不足以成为函数的重载。

**C++如何实现重载的**

C++代码在编译时会根据参数列表对函数进行重命名，例如void Swap(int a, int b)会被重命名为_Swap_int_int，void Swap(float x, float y)会被重命名为_Swap_float_float。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做重载决议（Overload Resolution）。

```
不同的编译器有不同的重命名方式，这里仅仅举例说明，实际情况可能并非如此。
```

从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。



**多个参数时的二义性**

在设计重载函数时，参数类型过少或者过多都容易引起二义性错误，因为这些类型相近，彼此之间会相互转换。

例如我们要设计几个重载函数来处理数值，数值包括小数和整数，如果只提供了以下两个函数原型：

```c++
void func(int);
void func(double);
```

那么下面的函数调用就会产生二义性错误：

```c++
long n = 1000;func(n);
```

n 是 long 类型，转换为 int 或 double 的优先级都是一样的，编译器不知道如何抉择。

如果添加一个函数原型`void func(long);`，或者去掉一个函数原型`void func(int);`，无论再怎么调用也不会出错了。



### 2.3 函数传值

函数的形参与实参结合的两种方式（传值、传址），其本质区别在于形参与实参结合时，是否在内存空间临时的创建新的内存区域并进行赋值操作。由此，也引发出了两种参数结合方式各自的优缺点，例如传值方式，效率较低，但安全性高；传址方式，效率高，但形参可影响实参的值，故安全性欠佳。

- 当函数的返回值是数组类型的，传递的是数组第一个元素的地址。
- 决定C++语言中函数的返回值类型的是在定义该函数时所指定的数据类型



### 2.4 内联函数

为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，类似于C语言中的宏展开。**这种在函数调用处直接嵌入函数体的函数称为内联函数（Inline Function），又称内嵌函数或者内置函数。**

**注意，要在函数定义处添加 inline 关键字，在函数声明处添加 inline 关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline 关键字。**

- 函数代码少、频繁调用适合使用内联函数
- 使用内联函数的目是提高程序运行速度



## 第三章

### 3.1 构造函数

一个类的对象被创建的时候，编译系统对象分配内存空间，并自动调用该构造函数，由构造函数完成成员的初始化工作。*因此，构造函数的核心作用就是，**初始化对象的数据成员***

- 名字与类名相同，可以有参数，但是不能有返回值（连void也不行）。
- 构造函数是在实例化对象时自动执行的，不需要手动调用。
- 作用是对对象进行初始化工作，如给成员变量赋值等。
- 如果定义类时没有写构造函数，系统会生成一个默认的无参构造函数，默认构造函数没有参数，不做任何工作。
- 如果定义了构造函数，系统不再生成默认的无参构造函数。
- 对象生成时构造函数自动调用，对象一旦生成，不能在其上再次执行构造函数。
- 一个类可以有多个构造函数，为重载关系。

**分类**

- 按参数种类分为：无参构造函数、有参构造函数、有默认参构造函数
- 按类型分为：普通构造函数、拷贝构造函数（赋值构造函数）

**拷贝构造函数**：

- 一种特殊的构造函数，当对象之间复制时会自动调用拷贝构造函数。
- 若类中没有显示定义拷贝构造函数，则系统会自动生成默认拷贝构造函数。
- 使用场合：旧对象初始化新对象 <font color=red>(注意是初始化，不是赋值)</font>
- 类中可以存在超过一个拷贝构造函数。

拷贝构造函数的判断

```c++
X::X(const X&);   //拷贝构造函数
X::X(X); 
X::X(X&, int a=1);   //拷贝构造函数
X::X(X&, int a=1, int b=2);  //拷贝构造函数
```

**对于一个类X, 如果一个构造函数的第一个参数是下列之一:
  a) X&
  b) const X&
  c) volatile X&
  d) const volatile X&
  且没有其他参数或其他参数都有默认值,那么这个函数是拷贝构造函数.**



### 3.2 析构函数

- 析构函数名是 ~类名；
- 无参数无返回值；
- 一个类有且只有一个析构函数；
- 析构函数无法重载
- 析构函数的作用主要是释放对象占用的资源
- 程序执行结束前，调用析构函数将数组中各个对象元素释放，释放顺序与创建对象的顺序相反。



### 3.3 友元函数

友元函数不是类的成员函数，只是独立于该类的一般函数。

一个类的友元函数可以访问该类的私有成员。



### 3.4 常成员函数

在类的成员函数说明后可以加const关键字,则该成员函数成为常成员函数。

两个函数,名字和参数表都一样,但是一个带const,一个不带,算重载。



### 3.4 this指针

每个成员函数 (包括构造和析构）都有一个this指针。

在成员函数内部，this指针指向调用对象，即可以通过this关键字访问当前对象的成员。

```
访问成员变量：this->成员名;
访问成员函数：this->函数名();
```

**this是指向对象的指针，而*this则指向对象的本体**

- this指针在成员函数执行前就已经存在，在析构后清除。
- this指针的类型为类类型*const（类名 *const）为右值。
- this指针本身不占用大小，他并不是对象的一部分，不会影响sizeof()的结果。
- this的作用域在类成员函数的内部。
- this指针是类成员函数的第一个默认隐含参数（const *类名 this），编译器自动维护传递，类编写者不能显式传递。
- 只有在类的非静态成员函数中才可以使用this指针，其他任何函数都不可以。
- this指针作用：（1）解决名称冲突（2）可以用来返回当前对象的引用。
- 任何对类成员的直接访问（使用成员访问运算符::）都可被看作是对this的隐式引用。



### 3.5 静态成员变量

静态数据成员不能在类中初始化，使用时需要在类体外声明。

