---
title: Etcd
abbrlink: 10
categories: etcd学习笔记
tags: etcd
updated: 2024-02-13
date: 2025-02-13
---

etcd是一个高可用、强一致的小型分布式key-value存储系统，广泛用于服务发现、配置共享、集群监控等场景。

它使用Raft算法，保证强一致性和高可用性。

与Redis相比，etcd在分布式环境中更具可靠性和一致性。

而相较于ZooKeeper，etcd更简单、易维护，并具有更快的更新周期。

etcd常见的应用场景包括服务发现、配置中心、分布式锁和负载均衡，能够通过强一致的存储和API支持分布式系统的高效运行。

<!-- more -->

# 01.介绍

## 1、etcd介绍

- etcd是一个 高可用、强一致 的小型分布式key-value存储系统
- 可以用于配置共享和服务的注册和发现，类似项目有zookeeper和consul
- 主要用于：共享配置、服务发现、集群监控、leader选举、分布式锁等场景
- etcd具有以下特点：
  - `简单`：包括一个定义良好、面向用户的API（gRPC）
  - `安全`：实现了带有可选的客户端证书身份验证的自动化TLS
  - `快速`：每秒10000次写入的基准速度
  - `可靠`：使用Raft算法实现了强一致、高可用的服务存储目录
  - 完全复制：集群中的每个节点都可以使用完整的存档
  - 高可用性：Etcd可用于避免硬件的单点故障或网络问题
  - 一致性：每次读取都会返回跨多主机的最新写入

## 2、etcd与Redis差异

etcd和Redis都支持键值存储，也支持分布式特性，Redis支持的数据格式更加丰富，但是他们两个定位和应用场景不一样，关键差异如下

- `Redis在分布式环境下不是强一致性的，可能会丢失数据，或者读取不到最新数据`
- Redis的数据变化监听机制没有etcd完善
- etcd强一致性保证数据可靠性，导致性能上要低于Redis
- `etcd和ZooKeeper是定位类似的项目，跟Redis定位不一样`

## 3、用etcd而不用ZK

相较之下，ZooKeeper有如下缺点

- `复杂`：
  - ZooKeeper的部署维护复杂，管理员需要掌握一系列的知识和技能；
  - 而 Paxos 强一致性算法也是素来以复杂难懂而闻名于世；
  - 另外，ZooKeeper的使用也比较复杂，需要安装客户端，官方只提供了 Java 和 C 两种语言的接口
- `难以维护`：
  - java 编写，Java 本身就偏向于重型应用，它会引入大量的依赖
  - 而运维人员则普遍希望保持强一致、高可用的机器集群尽可能简单，维护起来也不易出错
- `发展缓慢`：
  - Apache 基金会项目特有的“Apache Way”在开源界饱受争议
  - 其中一大原因就是由于基金会庞大的结构以及松散的管理导致项目发展缓慢

而 etcd 作为一个后起之秀，其优点也很明显

- `简单`：使用 Go 语言编写部署简单；使用 HTTP 作为接口使用简单；使用 Raft 算法保证强一致性让用户易于理解
- `数据持久化`：etcd 默认数据一更新就进行持久化
- `安全`：etcd 支持 SSL 客户端安全认证

# 02.etcd应用场景

## 1、服务发现

- 服务发现要解决的也是分布式系统中最常见的问题之一，即在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接
- 本质上来说，服务发现就是想要了解集群中是否有进程在监听 udp 或 tcp 端口，并且通过名字就可以查找和连接
- 而要解决服务发现的问题，需要满足如下三个方面，缺一不可
- 1）一个`强一致性`、高可用的服务存储目录
  - 基于Raft算法的etcd天生就是这样一个强一致性高可用的服务存储目录【安全的记录集群中的应用或服务的信息(地址、端口等)】
- 2）一种注册服务和监控服务`健康状态`的机制
  - 用户可以在etcd中注册服务，并且对注册的服务设置key TTL，定时保持服务的心跳以达到监控健康状态的效果
  - 能够完成新的应用或服务的注册添加进来，同样也能对现有的服务是否可用进行监控】
- 3）一种`查找和连接服务的机制`
  - 通过在etcd指定的主题下注册的服务也能在对应的主题下查找到
  - 为了确保连接，我们可以在每个服务机器上都部署一个Proxy模式的etcd，这样就可以确保能访问etcd集群的服务都能互相连接
  - 【已有的服务当被使用能够被找到并能连接】

![img](image/image-20220107112025144.035c87cd.png)

## 2、配置中心

**etcd的应用场景优化都是围绕存储的东西是“配置” 来设定的**

- 配置的数据量通常都不大，`所以默认etcd的存储上限是1GB`
- 配置通常对历史版本信息是比较关心的，所以`etcd会保存 版本（revision） 信息`
- 配置变更是比较常见的，并且业务程序会需要实时知道，`所以etcd提供了watch机制，基本就是实时通知配置变化`
- 配置的准确性一致性极其重要，所以etcd`采用raft算法，保证系统的CP`
- 同一份配置通常会被大量客户端同时访问，针对这个做了grpc proxy对同一个key的watcher做了优化
- 配置会被不同的业务部门使用，提供了权限控制和namespace机制

## 3、分布式锁

- 因为 etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁
- 锁服务有两种使用方式，一是保持独占，二是控制时序
- 保持独占
  - 保持独占即所有获取锁的用户最终只有一个可以得到
  - etcd 为此提供了一套实现分布式锁原子操作 CAS（CompareAndSwap）的 API
  - 通过设置prevExist值，可以保证在多个节点同时去创建某个目录时，只有一个成功
  - 而创建成功的用户就可以认为是获得了锁
- 控制时序
  - 控制时序，即所有想要获得锁的用户都会被安排执行，但是获得锁的顺序也是全局唯一的，同时决定了执行顺序
  - etcd 为此也提供了一套 API（自动创建有序键），对一个目录建值时指定为POST动作
  - 这样 etcd 会自动在目录下生成一个当前最大的值为键，存储这个新的值（客户端编号）
  - 同时还可以使用 API 按顺序列出所有当前目录下的键值
  - 此时这些键的值就是客户端的时序，而这些键中存储的值可以是代表客户端的编号

![img](image/image-20220107112139616.402af84f.png)

### 4、负载均衡

- 分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份
- 以此达到对等服务，即使其中的某一个服务失效了，也不影响使用
- 由此带来的坏处是数据写入性能下降，而好处则是数据访问时的负载均衡
- 因为每个对等服务节点上都存有完整的数据，所以用户的访问流量就可以分流到不同的机器上
- **etcd本身分布式架构存储的信息访问支持负载均衡**
  - etcd集群化以后，每个etcd的核心节点都可以处理用户的请求
  - 所以，把数据量小但是访问频繁的消息数据直接存储到etcd中也是个不错的选择
  - 如业务系统中常用的二级代码表（在表中存储代码，在etcd中存储代码所代表的具体含义）
- **利用etcd维护一个负载均衡节点表**
  - etcd可以监控一个集群中多个节点的状态，当有一个请求发过来后，可以轮询式的把请求转发给存活着的多个状态
  - 类似KafkaMQ，通过ZooKeeper来维护生产者和消费者的负载均衡同样也可以用etcd来做ZooKeeper的工作

### 5、分布式队列

- 创建一个先进先出的队列，保证顺序，**在保证队列达到某个条件时再统一按顺序执行**
- 这种方法的实现可以在/queue这个目录中另外建立一个/queue/condition节点









End



